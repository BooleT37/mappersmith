import { configs } from '../mappersmith'
import MockRequest from './mock-request'
import MockAssert from './mock-assert'
import Request from '../request'

const VALUE_NOT_MATCHED = '<MAPPERSMITH_VALUE_NOT_MATCHED>'

/**
 * @param {Integer} id
 * @param {Object} client - the client generated by {@link forge}
 */
function MockResource (id, client) {
  if (!client || !client._manifest) {
    throw new Error('[Mappersmith Test] "mockClient" received an invalid client')
  }

  this.id = id
  this.manifest = client._manifest
  this.resourceName = null
  this.methodName = null
  this.requestParams = {}
  this.responseData = null
  this.responseHandler = null
  this.responseHeaders = {}
  this.responseStatus = 200
  this.responseStatusHandler = null
  this.mockRequest = null
  this.asyncFinalRequest = null
}

MockResource.prototype = {
  /**
   * @return {MockResource}
   */
  resource (resourceName) {
    this.resourceName = resourceName
    return this
  },

  /**
   * @return {MockResource}
   */
  method (methodName) {
    this.methodName = methodName
    return this
  },

  /**
   * @return {MockResource}
   */
  with (requestParams) {
    this.requestParams = requestParams
    return this
  },

  /**
   * @return {MockResource}
   */
  headers (responseHeaders) {
    this.responseHeaders = responseHeaders
    return this
  },

  /**
   * @return {MockResource}
   */
  status (responder) {
    if (typeof responder === 'function') {
      this.responseStatusHandler = responder
    } else {
      this.responseStatus = responder
    }
    return this
  },

  /**
   * @return {MockResource}
   */
  response (responder) {
    if (typeof responder === 'function') {
      this.responseHandler = responder
    } else {
      this.responseData = responder
    }
    return this
  },

  /**
   * @return {Promise<MockAssert>}
   */
  assertObjectAsync () {
    return this.createAsyncRequest().then((finalRequest) => {
      this.asyncFinalRequest = finalRequest
      return this.toMockRequest().assertObject()
    })
  },

  /**
   * @return {MockAssert}
   */
  assertObject () {
    return this.toMockRequest().assertObject()
  },

  /**
   * @return {MockRequest}
   */
  toMockRequest () {
    const finalRequest = this.asyncFinalRequest
      ? this.asyncFinalRequest
      : this.createRequest()

    const assertObject = this.mockRequest
      ? this.mockRequest.assertObject()
      : new MockAssert([])

    const responseStatus = this.responseStatusHandler
      ? this.responseStatusHandler(finalRequest, assertObject)
      : this.responseStatus

    const responseData = this.responseHandler
      ? this.responseHandler(finalRequest, assertObject)
      : this.responseData

    if (!this.mockRequest) {
      const params = finalRequest.params()
      const hasParamMatchers = Object.keys(params).find((key) => typeof params[key] === 'function')
      const urlMatcher = (requestUrl, requestParams) => {
        const expandedParams = this.expandParams(params, requestParams)
        const testRequest = finalRequest.enhance({ params: expandedParams })
        return testRequest.url() === requestUrl
      }

      const url = hasParamMatchers ? urlMatcher : finalRequest.url()

      this.mockRequest = new MockRequest(this.id, {
        method: finalRequest.method(),
        url,
        body: finalRequest.body(),
        response: {
          status: responseStatus,
          headers: this.responseHeaders,
          body: responseData
        }
      })
    }

    this.mockRequest.responseStatus = responseStatus
    this.mockRequest.setResponseData(responseData)

    return this.mockRequest
  },

  /**
   * @private
   */
  expandParams (mockParams, requestParams) {
    return Object.keys(mockParams).reduce((obj, key) => {
      const value = requestParams[key]
      if (typeof mockParams[key] === 'function') {
        obj[key] = mockParams[key](value) ? value : VALUE_NOT_MATCHED
      } else {
        obj[key] = value
      }
      return obj
    }, {})
  },

    /**
   * @private
   */
  createRequest () {
    const methodDescriptor = this.manifest.createMethodDescriptor(this.resourceName, this.methodName)
    const initialRequest = new Request(methodDescriptor, this.requestParams)
    const middleware = this.manifest.createMiddleware({
      resourceName: this.resourceName,
      resourceMethod: this.methodName,
      mockRequest: true
    })
    return middleware
      .reduce((request, middleware) => middleware.request(request), initialRequest)
  },

  /**
   * @private
   */
  createAsyncRequest () {
    const methodDescriptor = this.manifest.createMethodDescriptor(this.resourceName, this.methodName)
    const initialRequest = new Request(methodDescriptor, this.requestParams)
    const middleware = this.manifest.createMiddleware({
      resourceName: this.resourceName,
      resourceMethod: this.methodName,
      mockRequest: true
    })
    return middleware
      .reduce(
        (requestPromise, middleware) =>
          requestPromise.then(request => middleware.request(request)),
        configs.Promise.resolve(initialRequest)
      )
  }
}

export default MockResource
